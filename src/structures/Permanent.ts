import {Color, Typeline} from "./Typeline";
import {Ability} from "./Ability";
import {ModificationLog} from "./ModificationLog";
import {Card, Counter} from "./Card";
import {capitalizeFirstLetter, deepCopy, getCssColor, joinList, shallowCopy} from "../Utilities";
import {Effect} from "./Effect";
import {Layer} from "../enumerations/Layer";
import {LinkMap} from "../dependencies/LinkMap";

export class Permanent {
    // Permanent features
    originalCard: Card;
    ownedByOpponent : boolean = false;
    phasedOut: boolean;
    counters: Counter[] = [];
    timestamp: number;
    // Characteristics
    name: string;
    power: number;
    toughness: number;
    color: Color[];
    typeline: Typeline;
    abilities: Ability[] = [];
    controlledByOpponent: boolean;
    // Transient
    modificationLog: ModificationLog = new ModificationLog();
    originalLink : Permanent = null;

    cssColor(): string {
        return getCssColor(this.color);
    }
    static fromCard(card: Card): Permanent {
        let p = new Permanent();
        p.originalCard = card;
        return p;
    }
    /**
     * Adds an ability to this permanent during a state check.
     * @param {Ability} ability The ability that's being add.
     * @param {Effect} source The effect that created the ability.
     */
    addAbility(ability: Ability, source : Effect) {
        ability.nonprinted = true;
        // 613.6a A continuous effect generated by a static ability has the same timestamp as the object the static ability is on, or the timestamp of the effect that created the ability, whichever is later.
        ability.effect.timestamp = Math.max(this.timestamp, source.timestamp);
        this.abilities.push(ability);
    }
    /**
     * Initializes a permanent at the beginning of a state check/
     * @param {number} timestamp The timestamp of this permanent.
     */
    beginStateCheck(timestamp : number) {
        // Copy card
        this.name = this.originalCard.name;
        this.power = this.originalCard.power;
        this.toughness = this.originalCard.toughness;
        this.color = shallowCopy(this.originalCard.color);
        this.typeline = this.originalCard.typeline.copy();
        this.abilities = deepCopy(this.originalCard.abilities);
        // Blank status
        this.controlledByOpponent = this.ownedByOpponent;
        this.modificationLog = new ModificationLog();
        this.originalLink = null;
        // Timestamp
        this.timestamp = timestamp;
        // Effects
        for (let ab of this.abilities) {
            ab.effect.source = this;
            ab.effect.timestamp = timestamp;
            // Blank transient fields
            ab.effect.blankTransientFields();
        }
    }
    describeColors() : string {
        let scolors : string[] = [];
        for (let clr of this.color) {
            scolors.push(Color[clr].toLowerCase());
        }
        return capitalizeFirstLetter(joinList(scolors));
    }

    createdLinkedCopy(map: LinkMap) {
        let linkedCopy : Permanent = map.getCopiedPermanent(this);
        /*// Permanent features
    originalCard: Card;
    ownedByOpponent : boolean = false;
    phasedOut: boolean;
    counters: Counter[] = [];
    timestamp: number;
    // Characteristics
    name: string;
    power: number;
    toughness: number;
    color: Color[];
    typeline: Typeline;
    abilities: Ability[] = [];
    controlledByOpponent: boolean;
    // Transient
    modificationLog: ModificationLog = new ModificationLog();
    originalLink : Permanent = null;*/
    }

    assumeCharacteristicsOfOriginal(map: LinkMap) {
        let original = this.originalLink;
        this.originalCard = original.originalCard;
        this.ownedByOpponent = original.ownedByOpponent;
        this.phasedOut = original.phasedOut;
        this.counters = original.counters;
        this.timestamp = original.timestamp;
        this.name = original.name;
        this.power = original.power;
        this.toughness = original.toughness;
        this.color = shallowCopy(original.color);
        this.typeline = original.typeline.copy();
        this.controlledByOpponent = original.controlledByOpponent;
        this.abilities = [];
        for (let ab of original.abilities) {
            this.abilities.push(ab.createdLinkedAbility(map));
        }
    }

    getPT() : [number, number] {
        return [ this.power, this.toughness];
    }
}